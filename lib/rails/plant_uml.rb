# frozen_string_literal: true

require "rails_erd"
require "rails_erd/diagram"
require "rails_erd/diagram/graphviz"
require "active_support/core_ext/string"
require "rails/plant_uml/railtie"

module RailsErd
  # PlantUML implementation of the Diagram class, which will output a .puml file
  # that can be processed by the PlantUML renderer.
  class PlantUml < RailsERD::Diagram
    setup do
      @markup = []
      @relationships = []
    end

    # Initialize the diagram
    def initialize(domain, options = {})
      @domain = domain
      @title = options[:title] || "Entity Relationship Diagram"
      @app_name = options[:app_name] || "SOFware"
      @filename = options[:filename] || "erd.puml"
      @filename += ".puml" unless @filename.end_with?(".puml")
      @only = options[:only]
      @timestamp = Time.current.iso8601
      @markup = []
    end

    # Main method to generate the PlantUML diagram
    def save
      # Generate the PlantUML content
      generate_diagram

      # Write to file
      File.write(@filename, @markup.join("\n"))

      # Return the filename so it can be used in the CLI output
      @filename
    end

    private

    # Assemble the full PlantUML diagram
    def generate_diagram
      # Start the PlantUML diagram with a name based on the title
      diagram_name = @title ? @title.gsub(/\s+/, "_") : "ERD"
      @markup << "@startuml #{diagram_name}"

      # Add title if provided
      @markup << "title #{@title}".indent(2) if @title

      # Add creation timestamp as a note
      @markup << "note \"Generated by #{@app_name} on #{@timestamp}\" as GenerationNote".indent(2)

      if @only
        @domain.entities.select { |e| @only.include?(e.name) }
      else
        @domain.entities
      end.each do |entity|
        add_entity(entity)
      end

      if @only
        @domain.relationships.select { |r| @only.include?(r.source.name) && @only.include?(r.destination.name) }
      else
        @domain.relationships
      end.each do |relationship|
        add_relationship(relationship)
      end

      # End the PlantUML diagram
      @markup << "@enduml"
    end

    # Convert an entity (model) to PlantUML class notation
    def add_entity(entity)
      # Start class definition
      @markup << "class #{entity.name} {".indent(2)

      # Get foreign key attributes directly
      foreign_key_attributes = entity.attributes.select { |attr| attr.foreign_key? }

      # Only show foreign keys section if there are foreign keys
      if foreign_key_attributes.any?
        @markup << "  .. Foreign Keys ..".indent(2)
        foreign_key_attributes.each do |attribute|
          @markup << "  + #{attribute.name} : #{attribute.type}".indent(2)
        end
      end

      # End class definition
      @markup << "}".indent(2)
      @markup << ""  # Empty line for readability
    end

    # Convert a relationship to PlantUML relationship notation
    def add_relationship(relationship)
      source = relationship.source.name
      destination = relationship.destination.name

      # Get the Rails models to check their associations
      source_model = begin
        source.constantize
      rescue
        nil
      end
      destination_model = begin
        destination.constantize
      rescue
        nil
      end

      # Default to the relationship cardinality from RailsERD
      cardinality = relationship.cardinality

      # Try to determine the relationship type from Rails models
      if source_model && destination_model && source_model.is_a?(Class) && destination_model.is_a?(Class)
        source_association = source_model.reflect_on_association(destination.underscore.to_sym)&.macro
        destination_association = destination_model.reflect_on_association(source.underscore.to_sym)&.macro

        cardinality = if ([source_association, destination_association].compact & [:belongs_to, :has_many]).present?
          :many
        elsif [source_association, destination_association].include? :has_one
          :one
        elsif source_model.reflect_on_association(destination.pluralize.underscore.to_sym)&.macro == :has_and_belongs_to_many ||
            destination_model.reflect_on_association(source.pluralize.underscore.to_sym)&.macro == :has_and_belongs_to_many
          :many_to_many
        end
      end

      # Determine relationship type and convert to PlantUML arrow notation
      @markup << case cardinality
      when :one
        # One-to-one relationship
        "#{source} \"1\" -- \"1\" #{destination}".indent(2)
      when :many
        # One-to-many relationship
        if relationship.source_optional?
          "#{source} \"0..1\" -- \"*\" #{destination}".indent(2)
        else
          "#{source} \"1\" -- \"*\" #{destination}".indent(2)
        end
      when :many_to_many
        # Many-to-many relationship
        "#{source} \"*\" -- \"*\" #{destination}".indent(2)
      else
        # Default relationship
        "#{source} -- #{destination}".indent(2)
      end
    end
  end
end
